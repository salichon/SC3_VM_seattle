# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4a
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
Codes for various geographical computations and filters
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Math', [dirname(__file__)])
        except ImportError:
            import _Math
            return _Math
        if fp is not None:
            try:
                _mod = imp.load_module('_Math', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Math = swig_import_helper()
    del swig_import_helper
else:
    import _Math
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _Math.SwigPyIterator_value(self)
    def incr(self, n = 1): return _Math.SwigPyIterator_incr(self, n)
    def decr(self, n = 1): return _Math.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _Math.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _Math.SwigPyIterator_equal(self, *args)
    def copy(self): return _Math.SwigPyIterator_copy(self)
    def next(self): return _Math.SwigPyIterator_next(self)
    def __next__(self): return _Math.SwigPyIterator___next__(self)
    def previous(self): return _Math.SwigPyIterator_previous(self)
    def advance(self, *args): return _Math.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _Math.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _Math.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _Math.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _Math.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _Math.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _Math.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _Math.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import Core
class vectorf(_object):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorf, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorf, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.vectorf_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.vectorf___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.vectorf___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _Math.vectorf___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _Math.vectorf_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectorf"""
        return _Math.vectorf___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, vectorf v = std::vector< float,std::allocator< float > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _Math.vectorf___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _Math.vectorf___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorf
        __getitem__(self, difference_type i) -> value_type
        """
        return _Math.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorf v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _Math.vectorf___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _Math.vectorf_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.vectorf_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _Math.vectorf_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.vectorf_clear(self)

    def swap(self, *args):
        """swap(self, vectorf v)"""
        return _Math.vectorf_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _Math.vectorf_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _Math.vectorf_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _Math.vectorf_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _Math.vectorf_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _Math.vectorf_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.vectorf_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _Math.vectorf_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorf
        __init__(self, vectorf arg0) -> vectorf
        __init__(self, size_type size) -> vectorf
        __init__(self, size_type size, value_type value) -> vectorf
        """
        this = _Math.new_vectorf(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _Math.vectorf_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _Math.vectorf_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _Math.vectorf_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _Math.vectorf_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _Math.vectorf_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _Math.vectorf_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _Math.vectorf_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _Math.vectorf_capacity(self)

    __swig_destroy__ = _Math.delete_vectorf
    __del__ = lambda self : None;
vectorf_swigregister = _Math.vectorf_swigregister
vectorf_swigregister(vectorf)

class vectord(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectord, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.vectord_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.vectord___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.vectord___bool__(self)

    def __len__(self):
        """__len__(self) -> size_type"""
        return _Math.vectord___len__(self)

    def pop(self):
        """pop(self) -> value_type"""
        return _Math.vectord_pop(self)

    def __getslice__(self, *args):
        """__getslice__(self, difference_type i, difference_type j) -> vectord"""
        return _Math.vectord___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, difference_type i, difference_type j, vectord v = std::vector< double,std::allocator< double > >())
        __setslice__(self, difference_type i, difference_type j)
        """
        return _Math.vectord___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(self, difference_type i, difference_type j)"""
        return _Math.vectord___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectord
        __getitem__(self, difference_type i) -> value_type
        """
        return _Math.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectord v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, difference_type i, value_type x)
        """
        return _Math.vectord___setitem__(self, *args)

    def append(self, *args):
        """append(self, value_type x)"""
        return _Math.vectord_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.vectord_empty(self)

    def size(self):
        """size(self) -> size_type"""
        return _Math.vectord_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.vectord_clear(self)

    def swap(self, *args):
        """swap(self, vectord v)"""
        return _Math.vectord_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> allocator_type"""
        return _Math.vectord_get_allocator(self)

    def begin(self):
        """begin(self) -> iterator"""
        return _Math.vectord_begin(self)

    def end(self):
        """end(self) -> iterator"""
        return _Math.vectord_end(self)

    def rbegin(self):
        """rbegin(self) -> reverse_iterator"""
        return _Math.vectord_rbegin(self)

    def rend(self):
        """rend(self) -> reverse_iterator"""
        return _Math.vectord_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.vectord_pop_back(self)

    def erase(self, *args):
        """
        erase(self, iterator pos) -> iterator
        erase(self, iterator first, iterator last) -> iterator
        """
        return _Math.vectord_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectord
        __init__(self, vectord arg0) -> vectord
        __init__(self, size_type size) -> vectord
        __init__(self, size_type size, value_type value) -> vectord
        """
        this = _Math.new_vectord(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, value_type x)"""
        return _Math.vectord_push_back(self, *args)

    def front(self):
        """front(self) -> value_type"""
        return _Math.vectord_front(self)

    def back(self):
        """back(self) -> value_type"""
        return _Math.vectord_back(self)

    def assign(self, *args):
        """assign(self, size_type n, value_type x)"""
        return _Math.vectord_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, size_type new_size)
        resize(self, size_type new_size, value_type x)
        """
        return _Math.vectord_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, iterator pos, value_type x) -> iterator
        insert(self, iterator pos, size_type n, value_type x)
        """
        return _Math.vectord_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, size_type n)"""
        return _Math.vectord_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> size_type"""
        return _Math.vectord_capacity(self)

    __swig_destroy__ = _Math.delete_vectord
    __del__ = lambda self : None;
vectord_swigregister = _Math.vectord_swigregister
vectord_swigregister(vectord)


def round(*args):
  """round(double val) -> double"""
  return _Math.round(*args)
class CoordF(Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Geo::Coord<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [Core.BaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordF, name, value)
    __swig_getmethods__ = {}
    for _s in [Core.BaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordF, name)
    __repr__ = _swig_repr
    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.CoordF_serialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CoordF
        __init__(self, float lat_, float lon_) -> CoordF
        """
        this = _Math.new_CoordF(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """set(self, float lat_, float lon_)"""
        return _Math.CoordF_set(self, *args)

    def latitude(self):
        """latitude(self) -> float"""
        return _Math.CoordF_latitude(self)

    def longitude(self):
        """longitude(self) -> float"""
        return _Math.CoordF_longitude(self)

    def __eq__(self, *args):
        """__eq__(self, CoordF other) -> bool"""
        return _Math.CoordF___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, CoordF other) -> bool"""
        return _Math.CoordF___ne__(self, *args)

    __swig_setmethods__["lat"] = _Math.CoordF_lat_set
    __swig_getmethods__["lat"] = _Math.CoordF_lat_get
    if _newclass:lat = _swig_property(_Math.CoordF_lat_get, _Math.CoordF_lat_set)
    __swig_setmethods__["lon"] = _Math.CoordF_lon_set
    __swig_getmethods__["lon"] = _Math.CoordF_lon_get
    if _newclass:lon = _swig_property(_Math.CoordF_lon_get, _Math.CoordF_lon_set)
    __swig_destroy__ = _Math.delete_CoordF
    __del__ = lambda self : None;
CoordF_swigregister = _Math.CoordF_swigregister
CoordF_swigregister(CoordF)

class CoordD(Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Geo::Coord<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [Core.BaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoordD, name, value)
    __swig_getmethods__ = {}
    for _s in [Core.BaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoordD, name)
    __repr__ = _swig_repr
    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.CoordD_serialize(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CoordD
        __init__(self, double lat_, double lon_) -> CoordD
        """
        this = _Math.new_CoordD(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """set(self, double lat_, double lon_)"""
        return _Math.CoordD_set(self, *args)

    def latitude(self):
        """latitude(self) -> double"""
        return _Math.CoordD_latitude(self)

    def longitude(self):
        """longitude(self) -> double"""
        return _Math.CoordD_longitude(self)

    def __eq__(self, *args):
        """__eq__(self, CoordD other) -> bool"""
        return _Math.CoordD___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(self, CoordD other) -> bool"""
        return _Math.CoordD___ne__(self, *args)

    __swig_setmethods__["lat"] = _Math.CoordD_lat_set
    __swig_getmethods__["lat"] = _Math.CoordD_lat_get
    if _newclass:lat = _swig_property(_Math.CoordD_lat_get, _Math.CoordD_lat_set)
    __swig_setmethods__["lon"] = _Math.CoordD_lon_set
    __swig_getmethods__["lon"] = _Math.CoordD_lon_get
    if _newclass:lon = _swig_property(_Math.CoordD_lon_get, _Math.CoordD_lon_set)
    __swig_destroy__ = _Math.delete_CoordD
    __del__ = lambda self : None;
CoordD_swigregister = _Math.CoordD_swigregister
CoordD_swigregister(CoordD)

class NamedCoordF(CoordF):
    """Proxy of C++ Seiscomp::Math::Geo::NamedCoord<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [CoordF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NamedCoordF, name, value)
    __swig_getmethods__ = {}
    for _s in [CoordF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NamedCoordF, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> NamedCoordF
        __init__(self, string name, float lat_, float lon_) -> NamedCoordF
        """
        this = _Math.new_NamedCoordF(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_NamedCoordF
    __del__ = lambda self : None;
    def set(self, *args):
        """
        set(self, float lat_, float lon_)
        set(self, string name, float lat_, float lon_)
        """
        return _Math.NamedCoordF_set(self, *args)

    def setName(self, *args):
        """setName(self, string name)"""
        return _Math.NamedCoordF_setName(self, *args)

    def name(self):
        """name(self) -> string"""
        return _Math.NamedCoordF_name(self)

    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.NamedCoordF_serialize(self, *args)

NamedCoordF_swigregister = _Math.NamedCoordF_swigregister
NamedCoordF_swigregister(NamedCoordF)

class NamedCoordD(CoordD):
    """Proxy of C++ Seiscomp::Math::Geo::NamedCoord<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [CoordD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NamedCoordD, name, value)
    __swig_getmethods__ = {}
    for _s in [CoordD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NamedCoordD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> NamedCoordD
        __init__(self, string name, double lat_, double lon_) -> NamedCoordD
        """
        this = _Math.new_NamedCoordD(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_NamedCoordD
    __del__ = lambda self : None;
    def set(self, *args):
        """
        set(self, double lat_, double lon_)
        set(self, string name, double lat_, double lon_)
        """
        return _Math.NamedCoordD_set(self, *args)

    def setName(self, *args):
        """setName(self, string name)"""
        return _Math.NamedCoordD_setName(self, *args)

    def name(self):
        """name(self) -> string"""
        return _Math.NamedCoordD_name(self)

    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.NamedCoordD_serialize(self, *args)

NamedCoordD_swigregister = _Math.NamedCoordD_swigregister
NamedCoordD_swigregister(NamedCoordD)

class HotspotListF(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::NamedCoordF)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotspotListF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HotspotListF, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.HotspotListF_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.HotspotListF___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.HotspotListF___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type"""
        return _Math.HotspotListF___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type"""
        return _Math.HotspotListF_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type j) -> HotspotListF
        """
        return _Math.HotspotListF___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type j, 
            HotspotListF v = std::vector< Seiscomp::Math::Geo::NamedCoord< float >,std::allocator< Seiscomp::Math::Geo::NamedCoord< float > > >())
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type j)
        """
        return _Math.HotspotListF___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type j)
        """
        return _Math.HotspotListF___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.HotspotListF___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> HotspotListF
        __getitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type
        """
        return _Math.HotspotListF___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, HotspotListF v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)
        """
        return _Math.HotspotListF___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)"""
        return _Math.HotspotListF_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.HotspotListF_empty(self)

    def size(self):
        """size(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type"""
        return _Math.HotspotListF_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.HotspotListF_clear(self)

    def swap(self, *args):
        """swap(self, HotspotListF v)"""
        return _Math.HotspotListF_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::allocator_type"""
        return _Math.HotspotListF_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator"""
        return _Math.HotspotListF_begin(self)

    def end(self):
        """end(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator"""
        return _Math.HotspotListF_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::reverse_iterator"""
        return _Math.HotspotListF_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::reverse_iterator"""
        return _Math.HotspotListF_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.HotspotListF_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator pos) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator
        erase(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator first, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator last) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator
        """
        return _Math.HotspotListF_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> HotspotListF
        __init__(self, HotspotListF arg0) -> HotspotListF
        __init__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type size) -> HotspotListF
        __init__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type size, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type value) -> HotspotListF
        """
        this = _Math.new_HotspotListF(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)"""
        return _Math.HotspotListF_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type"""
        return _Math.HotspotListF_front(self)

    def back(self):
        """back(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type"""
        return _Math.HotspotListF_back(self)

    def assign(self, *args):
        """
        assign(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)
        """
        return _Math.HotspotListF_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type new_size)
        resize(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type new_size, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)
        """
        return _Math.HotspotListF_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator
        insert(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::value_type x)
        """
        return _Math.HotspotListF_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type n)"""
        return _Math.HotspotListF_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(float)>)>::size_type"""
        return _Math.HotspotListF_capacity(self)

    __swig_destroy__ = _Math.delete_HotspotListF
    __del__ = lambda self : None;
HotspotListF_swigregister = _Math.HotspotListF_swigregister
HotspotListF_swigregister(HotspotListF)

class HotspotListD(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::NamedCoordD)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HotspotListD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HotspotListD, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.HotspotListD_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.HotspotListD___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.HotspotListD___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type"""
        return _Math.HotspotListD___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type"""
        return _Math.HotspotListD_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type j) -> HotspotListD
        """
        return _Math.HotspotListD___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type j, 
            HotspotListD v = std::vector< Seiscomp::Math::Geo::NamedCoord< double >,std::allocator< Seiscomp::Math::Geo::NamedCoord< double > > >())
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type j)
        """
        return _Math.HotspotListD___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type j)
        """
        return _Math.HotspotListD___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.HotspotListD___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> HotspotListD
        __getitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type
        """
        return _Math.HotspotListD___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, HotspotListD v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)
        """
        return _Math.HotspotListD___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)"""
        return _Math.HotspotListD_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.HotspotListD_empty(self)

    def size(self):
        """size(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type"""
        return _Math.HotspotListD_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.HotspotListD_clear(self)

    def swap(self, *args):
        """swap(self, HotspotListD v)"""
        return _Math.HotspotListD_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::allocator_type"""
        return _Math.HotspotListD_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator"""
        return _Math.HotspotListD_begin(self)

    def end(self):
        """end(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator"""
        return _Math.HotspotListD_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::reverse_iterator"""
        return _Math.HotspotListD_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::reverse_iterator"""
        return _Math.HotspotListD_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.HotspotListD_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator pos) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator
        erase(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator first, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator last) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator
        """
        return _Math.HotspotListD_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> HotspotListD
        __init__(self, HotspotListD arg0) -> HotspotListD
        __init__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type size) -> HotspotListD
        __init__(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type size, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type value) -> HotspotListD
        """
        this = _Math.new_HotspotListD(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)"""
        return _Math.HotspotListD_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type"""
        return _Math.HotspotListD_front(self)

    def back(self):
        """back(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type"""
        return _Math.HotspotListD_back(self)

    def assign(self, *args):
        """
        assign(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)
        """
        return _Math.HotspotListD_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type new_size)
        resize(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type new_size, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)
        """
        return _Math.HotspotListD_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator
        insert(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::value_type x)
        """
        return _Math.HotspotListD_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type n)"""
        return _Math.HotspotListD_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(Seiscomp::Math::Geo::NamedCoord<(double)>)>::size_type"""
        return _Math.HotspotListD_capacity(self)

    __swig_destroy__ = _Math.delete_HotspotListD
    __del__ = lambda self : None;
HotspotListD_swigregister = _Math.HotspotListD_swigregister
HotspotListD_swigregister(HotspotListD)

class CityF(NamedCoordF):
    """Proxy of C++ Seiscomp::Math::Geo::City<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [NamedCoordF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityF, name, value)
    __swig_getmethods__ = {}
    for _s in [NamedCoordF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CityF, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CityF
        __init__(self, string name, float lat_, float lon_, size_t population) -> CityF
        __init__(self, string name, string countryID, float lat_, float lon_, 
            size_t population) -> CityF
        """
        this = _Math.new_CityF(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_CityF
    __del__ = lambda self : None;
    def setPopulation(self, *args):
        """setPopulation(self, double population)"""
        return _Math.CityF_setPopulation(self, *args)

    def population(self):
        """population(self) -> double"""
        return _Math.CityF_population(self)

    def setCountryID(self, *args):
        """setCountryID(self, string arg0)"""
        return _Math.CityF_setCountryID(self, *args)

    def countryID(self):
        """countryID(self) -> string"""
        return _Math.CityF_countryID(self)

    def setCategory(self, *args):
        """setCategory(self, string arg0)"""
        return _Math.CityF_setCategory(self, *args)

    def category(self):
        """category(self) -> string"""
        return _Math.CityF_category(self)

    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.CityF_serialize(self, *args)

CityF_swigregister = _Math.CityF_swigregister
CityF_swigregister(CityF)

class CityD(NamedCoordD):
    """Proxy of C++ Seiscomp::Math::Geo::City<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [NamedCoordD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityD, name, value)
    __swig_getmethods__ = {}
    for _s in [NamedCoordD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CityD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CityD
        __init__(self, string name, double lat_, double lon_, size_t population) -> CityD
        __init__(self, string name, string countryID, double lat_, double lon_, 
            size_t population) -> CityD
        """
        this = _Math.new_CityD(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_CityD
    __del__ = lambda self : None;
    def setPopulation(self, *args):
        """setPopulation(self, double population)"""
        return _Math.CityD_setPopulation(self, *args)

    def population(self):
        """population(self) -> double"""
        return _Math.CityD_population(self)

    def setCountryID(self, *args):
        """setCountryID(self, string arg0)"""
        return _Math.CityD_setCountryID(self, *args)

    def countryID(self):
        """countryID(self) -> string"""
        return _Math.CityD_countryID(self)

    def setCategory(self, *args):
        """setCategory(self, string arg0)"""
        return _Math.CityD_setCategory(self, *args)

    def category(self):
        """category(self) -> string"""
        return _Math.CityD_category(self)

    def serialize(self, *args):
        """serialize(self, Archive ar)"""
        return _Math.CityD_serialize(self, *args)

CityD_swigregister = _Math.CityD_swigregister
CityD_swigregister(CityD)

class CityListF(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::CityF)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityListF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CityListF, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.CityListF_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.CityListF___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.CityListF___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type"""
        return _Math.CityListF___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type"""
        return _Math.CityListF_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type j) -> CityListF
        """
        return _Math.CityListF___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type j, 
            CityListF v = std::vector< Seiscomp::Math::Geo::City< float >,std::allocator< Seiscomp::Math::Geo::City< float > > >())
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type j)
        """
        return _Math.CityListF___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type j)
        """
        return _Math.CityListF___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.CityListF___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> CityListF
        __getitem__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type
        """
        return _Math.CityListF___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, CityListF v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)
        """
        return _Math.CityListF___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)"""
        return _Math.CityListF_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.CityListF_empty(self)

    def size(self):
        """size(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type"""
        return _Math.CityListF_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.CityListF_clear(self)

    def swap(self, *args):
        """swap(self, CityListF v)"""
        return _Math.CityListF_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::allocator_type"""
        return _Math.CityListF_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator"""
        return _Math.CityListF_begin(self)

    def end(self):
        """end(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator"""
        return _Math.CityListF_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::reverse_iterator"""
        return _Math.CityListF_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::reverse_iterator"""
        return _Math.CityListF_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.CityListF_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator pos) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator
        erase(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator first, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator last) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator
        """
        return _Math.CityListF_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CityListF
        __init__(self, CityListF arg0) -> CityListF
        __init__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type size) -> CityListF
        __init__(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type size, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type value) -> CityListF
        """
        this = _Math.new_CityListF(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)"""
        return _Math.CityListF_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type"""
        return _Math.CityListF_front(self)

    def back(self):
        """back(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type"""
        return _Math.CityListF_back(self)

    def assign(self, *args):
        """
        assign(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)
        """
        return _Math.CityListF_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type new_size)
        resize(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type new_size, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)
        """
        return _Math.CityListF_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator
        insert(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::City<(float)>)>::value_type x)
        """
        return _Math.CityListF_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type n)"""
        return _Math.CityListF_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(Seiscomp::Math::Geo::City<(float)>)>::size_type"""
        return _Math.CityListF_capacity(self)

    __swig_destroy__ = _Math.delete_CityListF
    __del__ = lambda self : None;
CityListF_swigregister = _Math.CityListF_swigregister
CityListF_swigregister(CityListF)

class CityListD(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Geo::CityD)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CityListD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CityListD, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.CityListD_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.CityListD___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.CityListD___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type"""
        return _Math.CityListD___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type"""
        return _Math.CityListD_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type j) -> CityListD
        """
        return _Math.CityListD___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type j, 
            CityListD v = std::vector< Seiscomp::Math::Geo::City< double >,std::allocator< Seiscomp::Math::Geo::City< double > > >())
        __setslice__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type j)
        """
        return _Math.CityListD___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type j)
        """
        return _Math.CityListD___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.CityListD___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> CityListD
        __getitem__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type
        """
        return _Math.CityListD___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, CityListD v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::difference_type i, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)
        """
        return _Math.CityListD___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)"""
        return _Math.CityListD_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.CityListD_empty(self)

    def size(self):
        """size(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type"""
        return _Math.CityListD_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.CityListD_clear(self)

    def swap(self, *args):
        """swap(self, CityListD v)"""
        return _Math.CityListD_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::allocator_type"""
        return _Math.CityListD_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator"""
        return _Math.CityListD_begin(self)

    def end(self):
        """end(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator"""
        return _Math.CityListD_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::reverse_iterator"""
        return _Math.CityListD_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::reverse_iterator"""
        return _Math.CityListD_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.CityListD_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator pos) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator
        erase(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator first, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator last) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator
        """
        return _Math.CityListD_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> CityListD
        __init__(self, CityListD arg0) -> CityListD
        __init__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type size) -> CityListD
        __init__(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type size, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type value) -> CityListD
        """
        this = _Math.new_CityListD(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)"""
        return _Math.CityListD_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type"""
        return _Math.CityListD_front(self)

    def back(self):
        """back(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type"""
        return _Math.CityListD_back(self)

    def assign(self, *args):
        """
        assign(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)
        """
        return _Math.CityListD_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type new_size)
        resize(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type new_size, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)
        """
        return _Math.CityListD_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator
        insert(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::iterator pos, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type n, 
            std::vector<(Seiscomp::Math::Geo::City<(double)>)>::value_type x)
        """
        return _Math.CityListD_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type n)"""
        return _Math.CityListD_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(Seiscomp::Math::Geo::City<(double)>)>::size_type"""
        return _Math.CityListD_capacity(self)

    __swig_destroy__ = _Math.delete_CityListD
    __del__ = lambda self : None;
CityListD_swigregister = _Math.CityListD_swigregister
CityListD_swigregister(CityListD)

class AlignmentError(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::AlignmentError class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AlignmentError, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AlignmentError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, char txt) -> AlignmentError"""
        this = _Math.new_AlignmentError(*args)
        try: self.this.append(this)
        except: self.this = this
    def what(self):
        """what(self) -> char"""
        return _Math.AlignmentError_what(self)

    __swig_destroy__ = _Math.delete_AlignmentError
    __del__ = lambda self : None;
AlignmentError_swigregister = _Math.AlignmentError_swigregister
AlignmentError_swigregister(AlignmentError)


def next_power_of_2(*args):
  """next_power_of_2(long arg0) -> long"""
  return _Math.next_power_of_2(*args)
class InPlaceFilterF(Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Filtering::InPlaceFilter<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [Core.BaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InPlaceFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [Core.BaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InPlaceFilterF, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_InPlaceFilterF
    __del__ = lambda self : None;
    def setStartTime(self, *args):
        """setStartTime(self, Time time)"""
        return _Math.InPlaceFilterF_setStartTime(self, *args)

    def setStreamID(self, *args):
        """setStreamID(self, string net, string sta, string loc, string cha)"""
        return _Math.InPlaceFilterF_setStreamID(self, *args)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.InPlaceFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.InPlaceFilterF_setParameters(self, *args)

    def apply(self, *args):
        """
        apply(self, int n, float inout)
        apply(self, vectorf f)
        apply(self, FloatArrayT arr)
        """
        return _Math.InPlaceFilterF_apply(self, *args)

    def handleGap(self, n = 0):
        """
        handleGap(self, int n = 0)
        handleGap(self)
        """
        return _Math.InPlaceFilterF_handleGap(self, n)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.InPlaceFilterF_clone(self)

    def Create(*args):
        """
        Create(string strFilter, string strError = None) -> InPlaceFilterF
        Create(string strFilter) -> InPlaceFilterF
        """
        return _Math.InPlaceFilterF_Create(*args)

    if _newclass:Create = staticmethod(Create)
    __swig_getmethods__["Create"] = lambda x: Create
InPlaceFilterF_swigregister = _Math.InPlaceFilterF_swigregister
InPlaceFilterF_swigregister(InPlaceFilterF)

def InPlaceFilterF_Create(*args):
  """
    Create(string strFilter, string strError = None) -> InPlaceFilterF
    InPlaceFilterF_Create(string strFilter) -> InPlaceFilterF
    """
  return _Math.InPlaceFilterF_Create(*args)

class InPlaceFilterD(Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Filtering::InPlaceFilter<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [Core.BaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InPlaceFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [Core.BaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InPlaceFilterD, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Math.delete_InPlaceFilterD
    __del__ = lambda self : None;
    def setStartTime(self, *args):
        """setStartTime(self, Time time)"""
        return _Math.InPlaceFilterD_setStartTime(self, *args)

    def setStreamID(self, *args):
        """setStreamID(self, string net, string sta, string loc, string cha)"""
        return _Math.InPlaceFilterD_setStreamID(self, *args)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.InPlaceFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.InPlaceFilterD_setParameters(self, *args)

    def apply(self, *args):
        """
        apply(self, int n, double inout)
        apply(self, vectord f)
        apply(self, DoubleArrayT arr)
        """
        return _Math.InPlaceFilterD_apply(self, *args)

    def handleGap(self, n = 0):
        """
        handleGap(self, int n = 0)
        handleGap(self)
        """
        return _Math.InPlaceFilterD_handleGap(self, n)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.InPlaceFilterD_clone(self)

    def Create(*args):
        """
        Create(string strFilter, string strError = None) -> InPlaceFilterD
        Create(string strFilter) -> InPlaceFilterD
        """
        return _Math.InPlaceFilterD_Create(*args)

    if _newclass:Create = staticmethod(Create)
    __swig_getmethods__["Create"] = lambda x: Create
InPlaceFilterD_swigregister = _Math.InPlaceFilterD_swigregister
InPlaceFilterD_swigregister(InPlaceFilterD)

def InPlaceFilterD_Create(*args):
  """
    Create(string strFilter, string strError = None) -> InPlaceFilterD
    InPlaceFilterD_Create(string strFilter) -> InPlaceFilterD
    """
  return _Math.InPlaceFilterD_Create(*args)

class AverageFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::Average<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AverageFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AverageFilterF, name)
    __repr__ = _swig_repr
    def __init__(self, timeSpan = 1.0, fsamp = 0.0): 
        """
        __init__(self, double timeSpan = 1.0, double fsamp = 0.0) -> AverageFilterF
        __init__(self, double timeSpan = 1.0) -> AverageFilterF
        __init__(self) -> AverageFilterF
        """
        this = _Math.new_AverageFilterF(timeSpan, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.AverageFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.AverageFilterF_setParameters(self, *args)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.AverageFilterF_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.AverageFilterF_clone(self)

    __swig_destroy__ = _Math.delete_AverageFilterF
    __del__ = lambda self : None;
AverageFilterF_swigregister = _Math.AverageFilterF_swigregister
AverageFilterF_swigregister(AverageFilterF)

class AverageFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::Average<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AverageFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AverageFilterD, name)
    __repr__ = _swig_repr
    def __init__(self, timeSpan = 1.0, fsamp = 0.0): 
        """
        __init__(self, double timeSpan = 1.0, double fsamp = 0.0) -> AverageFilterD
        __init__(self, double timeSpan = 1.0) -> AverageFilterD
        __init__(self) -> AverageFilterD
        """
        this = _Math.new_AverageFilterD(timeSpan, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.AverageFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.AverageFilterD_setParameters(self, *args)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.AverageFilterD_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.AverageFilterD_clone(self)

    __swig_destroy__ = _Math.delete_AverageFilterD
    __del__ = lambda self : None;
AverageFilterD_swigregister = _Math.AverageFilterD_swigregister
AverageFilterD_swigregister(AverageFilterD)

class STALTAFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::STALTA<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STALTAFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, STALTAFilterF, name)
    __repr__ = _swig_repr
    def __init__(self, lenSTA = 2, lenLTA = 50, fsamp = 1.): 
        """
        __init__(self, double lenSTA = 2, double lenLTA = 50, double fsamp = 1.) -> STALTAFilterF
        __init__(self, double lenSTA = 2, double lenLTA = 50) -> STALTAFilterF
        __init__(self, double lenSTA = 2) -> STALTAFilterF
        __init__(self) -> STALTAFilterF
        """
        this = _Math.new_STALTAFilterF(lenSTA, lenLTA, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSaveIntermediate(self, *args):
        """setSaveIntermediate(self, bool arg0)"""
        return _Math.STALTAFilterF_setSaveIntermediate(self, *args)

    def apply(self, *args):
        """apply(self, int ndata, float data)"""
        return _Math.STALTAFilterF_apply(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.STALTAFilterF_reset(self)

    def changed(self):
        """changed(self) -> bool"""
        return _Math.STALTAFilterF_changed(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.STALTAFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.STALTAFilterF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.STALTAFilterF_clone(self)

    def getSTA(self):
        """getSTA(self) -> vectorf"""
        return _Math.STALTAFilterF_getSTA(self)

    def getLTA(self):
        """getLTA(self) -> vectorf"""
        return _Math.STALTAFilterF_getLTA(self)

    __swig_destroy__ = _Math.delete_STALTAFilterF
    __del__ = lambda self : None;
STALTAFilterF_swigregister = _Math.STALTAFilterF_swigregister
STALTAFilterF_swigregister(STALTAFilterF)

class STALTAFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::STALTA<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, STALTAFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, STALTAFilterD, name)
    __repr__ = _swig_repr
    def __init__(self, lenSTA = 2, lenLTA = 50, fsamp = 1.): 
        """
        __init__(self, double lenSTA = 2, double lenLTA = 50, double fsamp = 1.) -> STALTAFilterD
        __init__(self, double lenSTA = 2, double lenLTA = 50) -> STALTAFilterD
        __init__(self, double lenSTA = 2) -> STALTAFilterD
        __init__(self) -> STALTAFilterD
        """
        this = _Math.new_STALTAFilterD(lenSTA, lenLTA, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSaveIntermediate(self, *args):
        """setSaveIntermediate(self, bool arg0)"""
        return _Math.STALTAFilterD_setSaveIntermediate(self, *args)

    def apply(self, *args):
        """apply(self, int ndata, double data)"""
        return _Math.STALTAFilterD_apply(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.STALTAFilterD_reset(self)

    def changed(self):
        """changed(self) -> bool"""
        return _Math.STALTAFilterD_changed(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.STALTAFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.STALTAFilterD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.STALTAFilterD_clone(self)

    def getSTA(self):
        """getSTA(self) -> vectord"""
        return _Math.STALTAFilterD_getSTA(self)

    def getLTA(self):
        """getLTA(self) -> vectord"""
        return _Math.STALTAFilterD_getLTA(self)

    __swig_destroy__ = _Math.delete_STALTAFilterD
    __del__ = lambda self : None;
STALTAFilterD_swigregister = _Math.STALTAFilterD_swigregister
STALTAFilterD_swigregister(STALTAFilterD)

class RunningMeanHighPassFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMeanHighPass<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanHighPassFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanHighPassFilterF, name)
    __repr__ = _swig_repr
    def __init__(self, windowLength = 0): 
        """
        __init__(self, double windowLength = 0) -> RunningMeanHighPassFilterF
        __init__(self) -> RunningMeanHighPassFilterF
        """
        this = _Math.new_RunningMeanHighPassFilterF(windowLength)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanHighPassFilterF
    __del__ = lambda self : None;
    def setLength(self, *args):
        """setLength(self, double windowLength)"""
        return _Math.RunningMeanHighPassFilterF_setLength(self, *args)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.RunningMeanHighPassFilterF_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.RunningMeanHighPassFilterF_clone(self)

    def reset(self):
        """reset(self)"""
        return _Math.RunningMeanHighPassFilterF_reset(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.RunningMeanHighPassFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.RunningMeanHighPassFilterF_setParameters(self, *args)

RunningMeanHighPassFilterF_swigregister = _Math.RunningMeanHighPassFilterF_swigregister
RunningMeanHighPassFilterF_swigregister(RunningMeanHighPassFilterF)

class RunningMeanHighPassFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::RunningMeanHighPass<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunningMeanHighPassFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RunningMeanHighPassFilterD, name)
    __repr__ = _swig_repr
    def __init__(self, windowLength = 0): 
        """
        __init__(self, double windowLength = 0) -> RunningMeanHighPassFilterD
        __init__(self) -> RunningMeanHighPassFilterD
        """
        this = _Math.new_RunningMeanHighPassFilterD(windowLength)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_RunningMeanHighPassFilterD
    __del__ = lambda self : None;
    def setLength(self, *args):
        """setLength(self, double windowLength)"""
        return _Math.RunningMeanHighPassFilterD_setLength(self, *args)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.RunningMeanHighPassFilterD_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.RunningMeanHighPassFilterD_clone(self)

    def reset(self):
        """reset(self)"""
        return _Math.RunningMeanHighPassFilterD_reset(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.RunningMeanHighPassFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.RunningMeanHighPassFilterD_setParameters(self, *args)

RunningMeanHighPassFilterD_swigregister = _Math.RunningMeanHighPassFilterD_swigregister
RunningMeanHighPassFilterD_swigregister(RunningMeanHighPassFilterD)

class InitialTaperFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::InitialTaper<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialTaperFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialTaperFilterF, name)
    __repr__ = _swig_repr
    def __init__(self, taperLength = 0, offset = 0): 
        """
        __init__(self, double taperLength = 0, float offset = 0) -> InitialTaperFilterF
        __init__(self, double taperLength = 0) -> InitialTaperFilterF
        __init__(self) -> InitialTaperFilterF
        """
        this = _Math.new_InitialTaperFilterF(taperLength, offset)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_InitialTaperFilterF
    __del__ = lambda self : None;
    def setLength(self, *args):
        """
        setLength(self, double taperLength, float offset = 0)
        setLength(self, double taperLength)
        """
        return _Math.InitialTaperFilterF_setLength(self, *args)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.InitialTaperFilterF_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.InitialTaperFilterF_clone(self)

    def reset(self):
        """reset(self)"""
        return _Math.InitialTaperFilterF_reset(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.InitialTaperFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.InitialTaperFilterF_setParameters(self, *args)

InitialTaperFilterF_swigregister = _Math.InitialTaperFilterF_swigregister
InitialTaperFilterF_swigregister(InitialTaperFilterF)

class InitialTaperFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::InitialTaper<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitialTaperFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitialTaperFilterD, name)
    __repr__ = _swig_repr
    def __init__(self, taperLength = 0, offset = 0): 
        """
        __init__(self, double taperLength = 0, double offset = 0) -> InitialTaperFilterD
        __init__(self, double taperLength = 0) -> InitialTaperFilterD
        __init__(self) -> InitialTaperFilterD
        """
        this = _Math.new_InitialTaperFilterD(taperLength, offset)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_InitialTaperFilterD
    __del__ = lambda self : None;
    def setLength(self, *args):
        """
        setLength(self, double taperLength, double offset = 0)
        setLength(self, double taperLength)
        """
        return _Math.InitialTaperFilterD_setLength(self, *args)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.InitialTaperFilterD_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.InitialTaperFilterD_clone(self)

    def reset(self):
        """reset(self)"""
        return _Math.InitialTaperFilterD_reset(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.InitialTaperFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.InitialTaperFilterD_setParameters(self, *args)

InitialTaperFilterD_swigregister = _Math.InitialTaperFilterD_swigregister
InitialTaperFilterD_swigregister(InitialTaperFilterD)

class _Biquad(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::_Biquad class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Biquad, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Biquad, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double _a0 = 1, double _a1 = 0, double _a2 = 0, double _b0 = 1, 
            double _b1 = 0, double _b2 = 0) -> _Biquad
        __init__(self, double _a0 = 1, double _a1 = 0, double _a2 = 0, double _b0 = 1, 
            double _b1 = 0) -> _Biquad
        __init__(self, double _a0 = 1, double _a1 = 0, double _a2 = 0, double _b0 = 1) -> _Biquad
        __init__(self, double _a0 = 1, double _a1 = 0, double _a2 = 0) -> _Biquad
        __init__(self, double _a0 = 1, double _a1 = 0) -> _Biquad
        __init__(self, double _a0 = 1) -> _Biquad
        __init__(self) -> _Biquad
        __init__(self, _Biquad other) -> _Biquad
        """
        this = _Math.new__Biquad(*args)
        try: self.this.append(this)
        except: self.this = this
    def set(self, *args):
        """
        set(self, double _a0, double _a1, double _a2, double _b0, double _b1, 
            double _b2)
        """
        return _Math._Biquad_set(self, *args)

    def delay(self, *args):
        """delay(self, int nsamp, double delay_val) -> int"""
        return _Math._Biquad_delay(self, *args)

    def delay2(self, *args):
        """delay2(self, int nsamp, double delay_val) -> int"""
        return _Math._Biquad_delay2(self, *args)

    def delay_one(self, *args):
        """delay_one(self, double freq, double delay) -> int"""
        return _Math._Biquad_delay_one(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math._Biquad_reset(self)

    def _print(self):
        """_print(self) -> string"""
        return _Math._Biquad__print(self)

    __swig_setmethods__["a0"] = _Math._Biquad_a0_set
    __swig_getmethods__["a0"] = _Math._Biquad_a0_get
    if _newclass:a0 = _swig_property(_Math._Biquad_a0_get, _Math._Biquad_a0_set)
    __swig_setmethods__["a1"] = _Math._Biquad_a1_set
    __swig_getmethods__["a1"] = _Math._Biquad_a1_get
    if _newclass:a1 = _swig_property(_Math._Biquad_a1_get, _Math._Biquad_a1_set)
    __swig_setmethods__["a2"] = _Math._Biquad_a2_set
    __swig_getmethods__["a2"] = _Math._Biquad_a2_get
    if _newclass:a2 = _swig_property(_Math._Biquad_a2_get, _Math._Biquad_a2_set)
    __swig_setmethods__["b0"] = _Math._Biquad_b0_set
    __swig_getmethods__["b0"] = _Math._Biquad_b0_get
    if _newclass:b0 = _swig_property(_Math._Biquad_b0_get, _Math._Biquad_b0_set)
    __swig_setmethods__["b1"] = _Math._Biquad_b1_set
    __swig_getmethods__["b1"] = _Math._Biquad_b1_get
    if _newclass:b1 = _swig_property(_Math._Biquad_b1_get, _Math._Biquad_b1_set)
    __swig_setmethods__["b2"] = _Math._Biquad_b2_set
    __swig_getmethods__["b2"] = _Math._Biquad_b2_get
    if _newclass:b2 = _swig_property(_Math._Biquad_b2_get, _Math._Biquad_b2_set)
    __swig_setmethods__["v1"] = _Math._Biquad_v1_set
    __swig_getmethods__["v1"] = _Math._Biquad_v1_get
    if _newclass:v1 = _swig_property(_Math._Biquad_v1_get, _Math._Biquad_v1_set)
    __swig_setmethods__["v2"] = _Math._Biquad_v2_set
    __swig_getmethods__["v2"] = _Math._Biquad_v2_get
    if _newclass:v2 = _swig_property(_Math._Biquad_v2_get, _Math._Biquad_v2_set)
    __swig_destroy__ = _Math.delete__Biquad
    __del__ = lambda self : None;
_Biquad_swigregister = _Math._Biquad_swigregister
_Biquad_swigregister(_Biquad)

class BiquadCascadeF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::BiquadCascade<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BiquadCascadeF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BiquadCascadeF, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> BiquadCascadeF
        __init__(self, BiquadCascadeF other) -> BiquadCascadeF
        """
        this = _Math.new_BiquadCascadeF(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_BiquadCascadeF
    __del__ = lambda self : None;
    def size(self):
        """size(self) -> int"""
        return _Math.BiquadCascadeF_size(self)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.BiquadCascadeF_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.BiquadCascadeF_clone(self)

    def filter(self, *args):
        """filter(self, vectorf f) -> vectorf"""
        return _Math.BiquadCascadeF_filter(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.BiquadCascadeF_reset(self)

    def _print(self):
        """_print(self) -> string"""
        return _Math.BiquadCascadeF__print(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double arg0)"""
        return _Math.BiquadCascadeF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.BiquadCascadeF_setParameters(self, *args)

    def append(self, *args):
        """append(self, Seiscomp::Math::Filtering::IIR::Biquad<(float)> biq)"""
        return _Math.BiquadCascadeF_append(self, *args)

BiquadCascadeF_swigregister = _Math.BiquadCascadeF_swigregister
BiquadCascadeF_swigregister(BiquadCascadeF)

class BiquadCascadeD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::BiquadCascade<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BiquadCascadeD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BiquadCascadeD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> BiquadCascadeD
        __init__(self, BiquadCascadeD other) -> BiquadCascadeD
        """
        this = _Math.new_BiquadCascadeD(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_BiquadCascadeD
    __del__ = lambda self : None;
    def size(self):
        """size(self) -> int"""
        return _Math.BiquadCascadeD_size(self)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.BiquadCascadeD_apply(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.BiquadCascadeD_clone(self)

    def filter(self, *args):
        """filter(self, vectord f) -> vectord"""
        return _Math.BiquadCascadeD_filter(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.BiquadCascadeD_reset(self)

    def _print(self):
        """_print(self) -> string"""
        return _Math.BiquadCascadeD__print(self)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double arg0)"""
        return _Math.BiquadCascadeD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.BiquadCascadeD_setParameters(self, *args)

    def append(self, *args):
        """append(self, Seiscomp::Math::Filtering::IIR::Biquad<(double)> biq)"""
        return _Math.BiquadCascadeD_append(self, *args)

BiquadCascadeD_swigregister = _Math.BiquadCascadeD_swigregister
BiquadCascadeD_swigregister(BiquadCascadeD)

class ButterworthLowpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthLowpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthLowpassF, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fc = 0.7, fsamp = 0): 
        """
        __init__(self, int order = 3, double fc = 0.7, double fsamp = 0) -> ButterworthLowpassF
        __init__(self, int order = 3, double fc = 0.7) -> ButterworthLowpassF
        __init__(self, int order = 3) -> ButterworthLowpassF
        __init__(self) -> ButterworthLowpassF
        """
        this = _Math.new_ButterworthLowpassF(order, fc, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthLowpassF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthLowpassF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.ButterworthLowpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthLowpassF
    __del__ = lambda self : None;
ButterworthLowpassF_swigregister = _Math.ButterworthLowpassF_swigregister
ButterworthLowpassF_swigregister(ButterworthLowpassF)

class ButterworthLowpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthLowpass<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthLowpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthLowpassD, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fc = 0.7, fsamp = 0): 
        """
        __init__(self, int order = 3, double fc = 0.7, double fsamp = 0) -> ButterworthLowpassD
        __init__(self, int order = 3, double fc = 0.7) -> ButterworthLowpassD
        __init__(self, int order = 3) -> ButterworthLowpassD
        __init__(self) -> ButterworthLowpassD
        """
        this = _Math.new_ButterworthLowpassD(order, fc, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthLowpassD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthLowpassD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.ButterworthLowpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthLowpassD
    __del__ = lambda self : None;
ButterworthLowpassD_swigregister = _Math.ButterworthLowpassD_swigregister
ButterworthLowpassD_swigregister(ButterworthLowpassD)

class ButterworthHighpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighpassF, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fc = 2.0, fsamp = 0): 
        """
        __init__(self, int order = 3, double fc = 2.0, double fsamp = 0) -> ButterworthHighpassF
        __init__(self, int order = 3, double fc = 2.0) -> ButterworthHighpassF
        __init__(self, int order = 3) -> ButterworthHighpassF
        __init__(self) -> ButterworthHighpassF
        """
        this = _Math.new_ButterworthHighpassF(order, fc, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthHighpassF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthHighpassF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.ButterworthHighpassF_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighpassF
    __del__ = lambda self : None;
ButterworthHighpassF_swigregister = _Math.ButterworthHighpassF_swigregister
ButterworthHighpassF_swigregister(ButterworthHighpassF)

class ButterworthHighpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthHighpass<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthHighpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthHighpassD, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fc = 2.0, fsamp = 0): 
        """
        __init__(self, int order = 3, double fc = 2.0, double fsamp = 0) -> ButterworthHighpassD
        __init__(self, int order = 3, double fc = 2.0) -> ButterworthHighpassD
        __init__(self, int order = 3) -> ButterworthHighpassD
        __init__(self) -> ButterworthHighpassD
        """
        this = _Math.new_ButterworthHighpassD(order, fc, fsamp)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthHighpassD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthHighpassD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.ButterworthHighpassD_clone(self)

    __swig_destroy__ = _Math.delete_ButterworthHighpassD
    __del__ = lambda self : None;
ButterworthHighpassD_swigregister = _Math.ButterworthHighpassD_swigregister
ButterworthHighpassD_swigregister(ButterworthHighpassD)

class ButterworthBandpassF(BiquadCascadeF):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandpassF, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandpassF, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fmin = 0.7, fmax = 2.0, fsamp = 0, init = False): 
        """
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0, 
            double fsamp = 0, bool init = False) -> ButterworthBandpassF
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0, 
            double fsamp = 0) -> ButterworthBandpassF
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0) -> ButterworthBandpassF
        __init__(self, int order = 3, double fmin = 0.7) -> ButterworthBandpassF
        __init__(self, int order = 3) -> ButterworthBandpassF
        __init__(self) -> ButterworthBandpassF
        """
        this = _Math.new_ButterworthBandpassF(order, fmin, fmax, fsamp, init)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthBandpassF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthBandpassF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.ButterworthBandpassF_clone(self)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.ButterworthBandpassF_apply(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.ButterworthBandpassF_reset(self)

    def handleGap(self, n = 0):
        """
        handleGap(self, int n = 0)
        handleGap(self)
        """
        return _Math.ButterworthBandpassF_handleGap(self, n)

    __swig_destroy__ = _Math.delete_ButterworthBandpassF
    __del__ = lambda self : None;
ButterworthBandpassF_swigregister = _Math.ButterworthBandpassF_swigregister
ButterworthBandpassF_swigregister(ButterworthBandpassF)

class ButterworthBandpassD(BiquadCascadeD):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::ButterworthBandpass<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ButterworthBandpassD, name, value)
    __swig_getmethods__ = {}
    for _s in [BiquadCascadeD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ButterworthBandpassD, name)
    __repr__ = _swig_repr
    def __init__(self, order = 3, fmin = 0.7, fmax = 2.0, fsamp = 0, init = False): 
        """
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0, 
            double fsamp = 0, bool init = False) -> ButterworthBandpassD
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0, 
            double fsamp = 0) -> ButterworthBandpassD
        __init__(self, int order = 3, double fmin = 0.7, double fmax = 2.0) -> ButterworthBandpassD
        __init__(self, int order = 3, double fmin = 0.7) -> ButterworthBandpassD
        __init__(self, int order = 3) -> ButterworthBandpassD
        __init__(self) -> ButterworthBandpassD
        """
        this = _Math.new_ButterworthBandpassD(order, fmin, fmax, fsamp, init)
        try: self.this.append(this)
        except: self.this = this
    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ButterworthBandpassD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ButterworthBandpassD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.ButterworthBandpassD_clone(self)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.ButterworthBandpassD_apply(self, *args)

    def reset(self):
        """reset(self)"""
        return _Math.ButterworthBandpassD_reset(self)

    def handleGap(self, n = 0):
        """
        handleGap(self, int n = 0)
        handleGap(self)
        """
        return _Math.ButterworthBandpassD_handleGap(self, n)

    __swig_destroy__ = _Math.delete_ButterworthBandpassD
    __del__ = lambda self : None;
ButterworthBandpassD_swigregister = _Math.ButterworthBandpassD_swigregister
ButterworthBandpassD_swigregister(ButterworthBandpassD)

class ChainFilterF(InPlaceFilterF):
    """Proxy of C++ Seiscomp::Math::Filtering::ChainFilter<(float)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainFilterF, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterF]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChainFilterF, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> ChainFilterF"""
        this = _Math.new_ChainFilterF()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_ChainFilterF
    __del__ = lambda self : None;
    def add(self, *args):
        """add(self, InPlaceFilterF filter) -> bool"""
        return _Math.ChainFilterF_add(self, *args)

    def remove(self, *args):
        """remove(self, size_t pos) -> bool"""
        return _Math.ChainFilterF_remove(self, *args)

    def take(self, *args):
        """take(self, size_t pos) -> InPlaceFilterF"""
        return _Math.ChainFilterF_take(self, *args)

    def indexOf(self, *args):
        """indexOf(self, InPlaceFilterF filter) -> size_t"""
        return _Math.ChainFilterF_indexOf(self, *args)

    def filterCount(self):
        """filterCount(self) -> size_t"""
        return _Math.ChainFilterF_filterCount(self)

    def apply(self, *args):
        """apply(self, int n, float inout)"""
        return _Math.ChainFilterF_apply(self, *args)

    def setStartTime(self, *args):
        """setStartTime(self, Time time)"""
        return _Math.ChainFilterF_setStartTime(self, *args)

    def setStreamID(self, *args):
        """setStreamID(self, string net, string sta, string loc, string cha)"""
        return _Math.ChainFilterF_setStreamID(self, *args)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ChainFilterF_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ChainFilterF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.ChainFilterF_clone(self)

ChainFilterF_swigregister = _Math.ChainFilterF_swigregister
ChainFilterF_swigregister(ChainFilterF)

class ChainFilterD(InPlaceFilterD):
    """Proxy of C++ Seiscomp::Math::Filtering::ChainFilter<(double)> class"""
    __swig_setmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ChainFilterD, name, value)
    __swig_getmethods__ = {}
    for _s in [InPlaceFilterD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ChainFilterD, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> ChainFilterD"""
        this = _Math.new_ChainFilterD()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_ChainFilterD
    __del__ = lambda self : None;
    def add(self, *args):
        """add(self, InPlaceFilterD filter) -> bool"""
        return _Math.ChainFilterD_add(self, *args)

    def remove(self, *args):
        """remove(self, size_t pos) -> bool"""
        return _Math.ChainFilterD_remove(self, *args)

    def take(self, *args):
        """take(self, size_t pos) -> InPlaceFilterD"""
        return _Math.ChainFilterD_take(self, *args)

    def indexOf(self, *args):
        """indexOf(self, InPlaceFilterD filter) -> size_t"""
        return _Math.ChainFilterD_indexOf(self, *args)

    def filterCount(self):
        """filterCount(self) -> size_t"""
        return _Math.ChainFilterD_filterCount(self)

    def apply(self, *args):
        """apply(self, int n, double inout)"""
        return _Math.ChainFilterD_apply(self, *args)

    def setStartTime(self, *args):
        """setStartTime(self, Time time)"""
        return _Math.ChainFilterD_setStartTime(self, *args)

    def setStreamID(self, *args):
        """setStreamID(self, string net, string sta, string loc, string cha)"""
        return _Math.ChainFilterD_setStreamID(self, *args)

    def setSamplingFrequency(self, *args):
        """setSamplingFrequency(self, double fsamp)"""
        return _Math.ChainFilterD_setSamplingFrequency(self, *args)

    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.ChainFilterD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.ChainFilterD_clone(self)

ChainFilterD_swigregister = _Math.ChainFilterD_swigregister
ChainFilterD_swigregister(ChainFilterD)

Displacement = _Math.Displacement
Velocity = _Math.Velocity
Acceleration = _Math.Acceleration
class PolesAndZeros(_object):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::PolesAndZeros class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolesAndZeros, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PolesAndZeros, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> PolesAndZeros
        __init__(self, Poles poles, Zeros zeros, double norm) -> PolesAndZeros
        __init__(self, PolesAndZeros other) -> PolesAndZeros
        """
        this = _Math.new_PolesAndZeros(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["poles"] = _Math.PolesAndZeros_poles_set
    __swig_getmethods__["poles"] = _Math.PolesAndZeros_poles_get
    if _newclass:poles = _swig_property(_Math.PolesAndZeros_poles_get, _Math.PolesAndZeros_poles_set)
    __swig_setmethods__["zeros"] = _Math.PolesAndZeros_zeros_set
    __swig_getmethods__["zeros"] = _Math.PolesAndZeros_zeros_get
    if _newclass:zeros = _swig_property(_Math.PolesAndZeros_zeros_get, _Math.PolesAndZeros_zeros_set)
    __swig_setmethods__["norm"] = _Math.PolesAndZeros_norm_set
    __swig_getmethods__["norm"] = _Math.PolesAndZeros_norm_get
    if _newclass:norm = _swig_property(_Math.PolesAndZeros_norm_get, _Math.PolesAndZeros_norm_set)
    __swig_destroy__ = _Math.delete_PolesAndZeros
    __del__ = lambda self : None;
PolesAndZeros_swigregister = _Math.PolesAndZeros_swigregister
PolesAndZeros_swigregister(PolesAndZeros)

class WoodAnderson(PolesAndZeros):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::WoodAnderson class"""
    __swig_setmethods__ = {}
    for _s in [PolesAndZeros]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WoodAnderson, name, value)
    __swig_getmethods__ = {}
    for _s in [PolesAndZeros]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WoodAnderson, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, GroundMotion input) -> WoodAnderson"""
        this = _Math.new_WoodAnderson(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_WoodAnderson
    __del__ = lambda self : None;
WoodAnderson_swigregister = _Math.WoodAnderson_swigregister
WoodAnderson_swigregister(WoodAnderson)

class Seismometer5sec(PolesAndZeros):
    """Proxy of C++ Seiscomp::Math::SeismometerResponse::Seismometer5sec class"""
    __swig_setmethods__ = {}
    for _s in [PolesAndZeros]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Seismometer5sec, name, value)
    __swig_getmethods__ = {}
    for _s in [PolesAndZeros]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Seismometer5sec, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, GroundMotion input) -> Seismometer5sec"""
        this = _Math.new_Seismometer5sec(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Math.delete_Seismometer5sec
    __del__ = lambda self : None;
Seismometer5sec_swigregister = _Math.Seismometer5sec_swigregister
Seismometer5sec_swigregister(Seismometer5sec)

class WWSSN_SPF(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(float)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WWSSN_SPF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WWSSN_SPF, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, GroundMotion input = Velocity) -> WWSSN_SPF
        __init__(self) -> WWSSN_SPF
        __init__(self, WWSSN_SPF other) -> WWSSN_SPF
        """
        this = _Math.new_WWSSN_SPF(*args)
        try: self.this.append(this)
        except: self.this = this
    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.WWSSN_SPF_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterF"""
        return _Math.WWSSN_SPF_clone(self)

    def setInput(self, *args):
        """setInput(self, GroundMotion input)"""
        return _Math.WWSSN_SPF_setInput(self, *args)

    __swig_destroy__ = _Math.delete_WWSSN_SPF
    __del__ = lambda self : None;
WWSSN_SPF_swigregister = _Math.WWSSN_SPF_swigregister
WWSSN_SPF_swigregister(WWSSN_SPF)

class WWSSN_SPD(_object):
    """Proxy of C++ Seiscomp::Math::Filtering::IIR::WWSSN_SP_Filter<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WWSSN_SPD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WWSSN_SPD, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, GroundMotion input = Velocity) -> WWSSN_SPD
        __init__(self) -> WWSSN_SPD
        __init__(self, WWSSN_SPD other) -> WWSSN_SPD
        """
        this = _Math.new_WWSSN_SPD(*args)
        try: self.this.append(this)
        except: self.this = this
    def setParameters(self, *args):
        """setParameters(self, int n, double params) -> int"""
        return _Math.WWSSN_SPD_setParameters(self, *args)

    def clone(self):
        """clone(self) -> InPlaceFilterD"""
        return _Math.WWSSN_SPD_clone(self)

    def setInput(self, *args):
        """setInput(self, GroundMotion input)"""
        return _Math.WWSSN_SPD_setInput(self, *args)

    __swig_destroy__ = _Math.delete_WWSSN_SPD
    __del__ = lambda self : None;
WWSSN_SPD_swigregister = _Math.WWSSN_SPD_swigregister
WWSSN_SPD_swigregister(WWSSN_SPD)


def delazi(*args):
  """delazi(double lat1, double lon1, double lat2, double lon2)"""
  return _Math.delazi(*args)

def delandaz2coord(*args):
  """delandaz2coord(double dist, double azi, double lat0, double lon0)"""
  return _Math.delandaz2coord(*args)

def scdraw(*args):
  """
    scdraw(double lat0, double lon0, double radius, int n, double lat, 
        double lon) -> int
    """
  return _Math.scdraw(*args)
KM_OF_DEGREE = _Math.KM_OF_DEGREE

def xyz2ltp(*args):
  """
    xyz2ltp(double x, double y, double z, double lat, double lon, 
        double alt)
    """
  return _Math.xyz2ltp(*args)

def ltp2xyz(*args):
  """
    ltp2xyz(double lat, double lon, double alt, double x, double y, 
        double z)
    """
  return _Math.ltp2xyz(*args)

def nearestHotspot(*args):
  """nearestHotspot(double lat, double lon, double maxDist, HotspotListD coords) -> NamedCoordD"""
  return _Math.nearestHotspot(*args)

def largestCity(*args):
  """largestCity(double lat, double lon, double maxDist, CityListD cities) -> CityD"""
  return _Math.largestCity(*args)
class PositionInterpolator(_object):
    """Proxy of C++ Seiscomp::Math::Geo::PositionInterpolator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PositionInterpolator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PositionInterpolator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, double lat1, double lon1, double lat2, double lon2, 
            int steps) -> PositionInterpolator
        __init__(self, double lat1, double lon1, double lat2, double lon2, 
            double stepsDistScale) -> PositionInterpolator
        """
        this = _Math.new_PositionInterpolator(*args)
        try: self.this.append(this)
        except: self.this = this
    def end(self):
        """end(self) -> bool"""
        return _Math.PositionInterpolator_end(self)

    def overallDistance(self):
        """overallDistance(self) -> double"""
        return _Math.PositionInterpolator_overallDistance(self)

    def distance(self):
        """distance(self) -> double"""
        return _Math.PositionInterpolator_distance(self)

    def azimuth(self):
        """azimuth(self) -> double"""
        return _Math.PositionInterpolator_azimuth(self)

    def latitude(self):
        """latitude(self) -> double"""
        return _Math.PositionInterpolator_latitude(self)

    def longitude(self):
        """longitude(self) -> double"""
        return _Math.PositionInterpolator_longitude(self)

    __swig_destroy__ = _Math.delete_PositionInterpolator
    __del__ = lambda self : None;
PositionInterpolator_swigregister = _Math.PositionInterpolator_swigregister
PositionInterpolator_swigregister(PositionInterpolator)

def scxsc(*args):
  """
    scxsc(double lat1, double lon1, double r1, double lat2, double lon2, 
        double r2, double latx1, double lonx1, 
        double latx2, double lonx2, double epsilon = 0) -> int
    scxsc(double lat1, double lon1, double r1, double lat2, double lon2, 
        double r2, double latx1, double lonx1, 
        double latx2, double lonx2) -> int
    """
  return _Math.scxsc(*args)

def nearestCity(*args):
  """
    nearestCity(double lat, double lon, double maxDist, double minPopulation, 
        int nCities, CityD cityArray) -> CityD
    nearestCity(double lat, double lon, double maxDist, double minPopulation, 
        CityListD cities) -> CityD
    """
  return _Math.nearestCity(*args)


def deg2km(*args):
  """deg2km(double deg) -> double"""
  return _Math.deg2km(*args)
class TransferFunction(Core.BaseObject):
    """Proxy of C++ Seiscomp::Math::Restitution::FFT::TransferFunction class"""
    __swig_setmethods__ = {}
    for _s in [Core.BaseObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransferFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [Core.BaseObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransferFunction, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __mul__(self, *args):
        """__mul__(self, TransferFunction a) -> TransferFunction"""
        return _Math.TransferFunction___mul__(self, *args)

    def __div__(self, *args):
        """__div__(self, TransferFunction a) -> TransferFunction"""
        return _Math.TransferFunction___div__(self, *args)

    def evaluate(self, *args):
        """
        evaluate(self, Complex out, int n, double x)
        evaluate(self, vectorc out, vectord x)
        """
        return _Math.TransferFunction_evaluate(self, *args)

    def deconvolve(self, *args):
        """
        deconvolve(self, int n, Complex spec, double startFreq, double df)
        deconvolve(self, vectorc spec, double startFreq, double df)
        """
        return _Math.TransferFunction_deconvolve(self, *args)

    def convolve(self, *args):
        """
        convolve(self, int n, Complex spec, double startFreq, double df)
        convolve(self, vectorc spec, double startFreq, double df)
        """
        return _Math.TransferFunction_convolve(self, *args)

    __swig_destroy__ = _Math.delete_TransferFunction
    __del__ = lambda self : None;
TransferFunction_swigregister = _Math.TransferFunction_swigregister
TransferFunction_swigregister(TransferFunction)

class TransferFunctionPAZ(TransferFunction):
    """Proxy of C++ Seiscomp::Math::Restitution::FFT::PolesAndZeros class"""
    __swig_setmethods__ = {}
    for _s in [TransferFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransferFunctionPAZ, name, value)
    __swig_getmethods__ = {}
    for _s in [TransferFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TransferFunctionPAZ, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        PolesAndZeros(PolesAndZeros polesAndZeros) -> TransferFunctionPAZ
        PolesAndZeros(int n_poles, Pole poles, int n_zeros, Zero zeros, double k, 
            int addZeros = 0) -> TransferFunctionPAZ
        __init__(self, int n_poles, Pole poles, int n_zeros, Zero zeros, double k) -> TransferFunctionPAZ
        """
        this = _Math.new_TransferFunctionPAZ(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["paz"] = _Math.TransferFunctionPAZ_paz_set
    __swig_getmethods__["paz"] = _Math.TransferFunctionPAZ_paz_get
    if _newclass:paz = _swig_property(_Math.TransferFunctionPAZ_paz_get, _Math.TransferFunctionPAZ_paz_set)
    __swig_destroy__ = _Math.delete_TransferFunctionPAZ
    __del__ = lambda self : None;
TransferFunctionPAZ_swigregister = _Math.TransferFunctionPAZ_swigregister
TransferFunctionPAZ_swigregister(TransferFunctionPAZ)

class vectorc(_object):
    """Proxy of C++ std::vector<(Seiscomp::Math::Complex)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorc, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorc, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(self) -> SwigPyIterator"""
        return _Math.vectorc_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(self) -> bool"""
        return _Math.vectorc___nonzero__(self)

    def __bool__(self):
        """__bool__(self) -> bool"""
        return _Math.vectorc___bool__(self)

    def __len__(self):
        """__len__(self) -> std::vector<(std::complex<(double)>)>::size_type"""
        return _Math.vectorc___len__(self)

    def pop(self):
        """pop(self) -> std::vector<(std::complex<(double)>)>::value_type"""
        return _Math.vectorc_pop(self)

    def __getslice__(self, *args):
        """
        __getslice__(self, std::vector<(std::complex<(double)>)>::difference_type i, 
            std::vector<(std::complex<(double)>)>::difference_type j) -> vectorc
        """
        return _Math.vectorc___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(self, std::vector<(std::complex<(double)>)>::difference_type i, 
            std::vector<(std::complex<(double)>)>::difference_type j, 
            vectorc v = std::vector< std::complex< double >,std::allocator< std::complex< double > > >())
        __setslice__(self, std::vector<(std::complex<(double)>)>::difference_type i, 
            std::vector<(std::complex<(double)>)>::difference_type j)
        """
        return _Math.vectorc___setslice__(self, *args)

    def __delslice__(self, *args):
        """
        __delslice__(self, std::vector<(std::complex<(double)>)>::difference_type i, 
            std::vector<(std::complex<(double)>)>::difference_type j)
        """
        return _Math.vectorc___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(self, std::vector<(std::complex<(double)>)>::difference_type i)
        __delitem__(self, PySliceObject slice)
        """
        return _Math.vectorc___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, PySliceObject slice) -> vectorc
        __getitem__(self, std::vector<(std::complex<(double)>)>::difference_type i) -> std::vector<(std::complex<(double)>)>::value_type
        """
        return _Math.vectorc___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, PySliceObject slice, vectorc v)
        __setitem__(self, PySliceObject slice)
        __setitem__(self, std::vector<(std::complex<(double)>)>::difference_type i, 
            std::vector<(std::complex<(double)>)>::value_type x)
        """
        return _Math.vectorc___setitem__(self, *args)

    def append(self, *args):
        """append(self, std::vector<(std::complex<(double)>)>::value_type x)"""
        return _Math.vectorc_append(self, *args)

    def empty(self):
        """empty(self) -> bool"""
        return _Math.vectorc_empty(self)

    def size(self):
        """size(self) -> std::vector<(std::complex<(double)>)>::size_type"""
        return _Math.vectorc_size(self)

    def clear(self):
        """clear(self)"""
        return _Math.vectorc_clear(self)

    def swap(self, *args):
        """swap(self, vectorc v)"""
        return _Math.vectorc_swap(self, *args)

    def get_allocator(self):
        """get_allocator(self) -> std::vector<(std::complex<(double)>)>::allocator_type"""
        return _Math.vectorc_get_allocator(self)

    def begin(self):
        """begin(self) -> std::vector<(std::complex<(double)>)>::iterator"""
        return _Math.vectorc_begin(self)

    def end(self):
        """end(self) -> std::vector<(std::complex<(double)>)>::iterator"""
        return _Math.vectorc_end(self)

    def rbegin(self):
        """rbegin(self) -> std::vector<(std::complex<(double)>)>::reverse_iterator"""
        return _Math.vectorc_rbegin(self)

    def rend(self):
        """rend(self) -> std::vector<(std::complex<(double)>)>::reverse_iterator"""
        return _Math.vectorc_rend(self)

    def pop_back(self):
        """pop_back(self)"""
        return _Math.vectorc_pop_back(self)

    def erase(self, *args):
        """
        erase(self, std::vector<(std::complex<(double)>)>::iterator pos) -> std::vector<(std::complex<(double)>)>::iterator
        erase(self, std::vector<(std::complex<(double)>)>::iterator first, 
            std::vector<(std::complex<(double)>)>::iterator last) -> std::vector<(std::complex<(double)>)>::iterator
        """
        return _Math.vectorc_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(self) -> vectorc
        __init__(self, vectorc arg0) -> vectorc
        __init__(self, std::vector<(std::complex<(double)>)>::size_type size) -> vectorc
        __init__(self, std::vector<(std::complex<(double)>)>::size_type size, 
            std::vector<(std::complex<(double)>)>::value_type value) -> vectorc
        """
        this = _Math.new_vectorc(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(self, std::vector<(std::complex<(double)>)>::value_type x)"""
        return _Math.vectorc_push_back(self, *args)

    def front(self):
        """front(self) -> std::vector<(std::complex<(double)>)>::value_type"""
        return _Math.vectorc_front(self)

    def back(self):
        """back(self) -> std::vector<(std::complex<(double)>)>::value_type"""
        return _Math.vectorc_back(self)

    def assign(self, *args):
        """
        assign(self, std::vector<(std::complex<(double)>)>::size_type n, 
            std::vector<(std::complex<(double)>)>::value_type x)
        """
        return _Math.vectorc_assign(self, *args)

    def resize(self, *args):
        """
        resize(self, std::vector<(std::complex<(double)>)>::size_type new_size)
        resize(self, std::vector<(std::complex<(double)>)>::size_type new_size, 
            std::vector<(std::complex<(double)>)>::value_type x)
        """
        return _Math.vectorc_resize(self, *args)

    def insert(self, *args):
        """
        insert(self, std::vector<(std::complex<(double)>)>::iterator pos, 
            std::vector<(std::complex<(double)>)>::value_type x) -> std::vector<(std::complex<(double)>)>::iterator
        insert(self, std::vector<(std::complex<(double)>)>::iterator pos, 
            std::vector<(std::complex<(double)>)>::size_type n, 
            std::vector<(std::complex<(double)>)>::value_type x)
        """
        return _Math.vectorc_insert(self, *args)

    def reserve(self, *args):
        """reserve(self, std::vector<(std::complex<(double)>)>::size_type n)"""
        return _Math.vectorc_reserve(self, *args)

    def capacity(self):
        """capacity(self) -> std::vector<(std::complex<(double)>)>::size_type"""
        return _Math.vectorc_capacity(self)

    __swig_destroy__ = _Math.delete_vectorc
    __del__ = lambda self : None;
vectorc_swigregister = _Math.vectorc_swigregister
vectorc_swigregister(vectorc)

# This file is compatible with both classic and new-style classes.


